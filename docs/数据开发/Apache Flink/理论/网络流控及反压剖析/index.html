<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-数据开发/Apache Flink/理论/网络流控及反压剖析">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">网络流控及反压剖析 | 大数据知识库</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://zhangyongtian.github.io/docs/数据开发/Apache Flink/理论/网络流控及反压剖析"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="网络流控及反压剖析 | 大数据知识库"><meta data-rh="true" name="description" content="网络流控的概念与背景"><meta data-rh="true" property="og:description" content="网络流控的概念与背景"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://zhangyongtian.github.io/docs/数据开发/Apache Flink/理论/网络流控及反压剖析"><link data-rh="true" rel="alternate" href="https://zhangyongtian.github.io/docs/数据开发/Apache Flink/理论/网络流控及反压剖析" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://zhangyongtian.github.io/en/docs/数据开发/Apache Flink/理论/网络流控及反压剖析" hreflang="en-GB"><link data-rh="true" rel="alternate" href="https://zhangyongtian.github.io/docs/数据开发/Apache Flink/理论/网络流控及反压剖析" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="大数据知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="大数据知识库 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.c7c4384d.css">
<link rel="preload" href="/assets/js/runtime~main.4dcd1c4b.js" as="script">
<link rel="preload" href="/assets/js/main.d89d1304.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="BigdataKnowledge Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="BigdataKnowledge Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">BigdataKnowledge</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/概览">文档</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhangyongtian/bigdataknowledge" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/概览">概览</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/开发者指南">开发者指南</a><button aria-label="打开/收起侧边栏菜单「开发者指南」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数仓理论">数仓理论</a><button aria-label="打开/收起侧边栏菜单「数仓理论」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数据质量">数据质量</a><button aria-label="打开/收起侧边栏菜单「数据质量」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数据集成">数据集成</a><button aria-label="打开/收起侧边栏菜单「数据集成」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数据协调">数据协调</a><button aria-label="打开/收起侧边栏菜单「数据协调」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数据调度">数据调度</a><button aria-label="打开/收起侧边栏菜单「数据调度」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/容器调度">容器调度</a><button aria-label="打开/收起侧边栏菜单「容器调度」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/数据存储">数据存储</a><button aria-label="打开/收起侧边栏菜单「数据存储」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/数据开发">数据开发</a><button aria-label="打开/收起侧边栏菜单「数据开发」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/category/apache-flink">Apache Flink</a><button aria-label="打开/收起侧边栏菜单「Apache Flink」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/category/理论">理论</a><button aria-label="打开/收起侧边栏菜单「理论」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/概览">概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/Runtime核心机制">Runtime核心机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/时间属性深度解析">时间属性深度解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/Checkpoint 原理剖析与应用实战">Checkpoint 原理剖析与应用实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/Flink 架构概览">Flink 架构概览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/数据类型和序列化">数据类型和序列化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/Flink 作业执行深度解析">Flink 作业执行深度解析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/数据开发/Apache Flink/理论/网络流控及反压剖析">网络流控及反压剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/Apache Flink/理论/End-to-End-Exactly-Once">End-to-End-Exactly-Once</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/实践">实践</a><button aria-label="打开/收起侧边栏菜单「实践」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/apache-paimon">Apache Paimon</a><button aria-label="打开/收起侧边栏菜单「Apache Paimon」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/apache-spark">Apache Spark</a><button aria-label="打开/收起侧边栏菜单「Apache Spark」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/apache-streampark">Apache StreamPark</a><button aria-label="打开/收起侧边栏菜单「Apache StreamPark」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/dinky">Dinky</a><button aria-label="打开/收起侧边栏菜单「Dinky」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/数据开发/概览">概览</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/平台监控">平台监控</a><button aria-label="打开/收起侧边栏菜单「平台监控」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/bi报表">BI报表</a><button aria-label="打开/收起侧边栏菜单「BI报表」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/自动化运维">自动化运维</a><button aria-label="打开/收起侧边栏菜单「自动化运维」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/项目实战案例">项目实战案例</a><button aria-label="打开/收起侧边栏菜单「项目实战案例」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/faq">FAQ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/comminicate">交流与贡献</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/数据开发"><span itemprop="name">数据开发</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/apache-flink"><span itemprop="name">Apache Flink</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/理论"><span itemprop="name">理论</span></a><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">网络流控及反压剖析</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>网络流控及反压剖析</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="网络流控的概念与背景">网络流控的概念与背景<a href="#网络流控的概念与背景" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么需要网络流控">为什么需要网络流控<a href="#为什么需要网络流控" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="背景图片" src="/assets/images/46fc4e9daae3e0beb3cc614aa9b72b2-7e28662bec4feaef63055c7aa7d2cce2.png" width="669" height="317" class="img_ev3q"></p><p>首先我们可以看下这张最精简的网络流控的图，<strong>Producer 的吞吐率是 2MB/s，Consumer 是 1MB/s</strong>，这个时候我们就会发现在网络通信的时候我们的 Producer的速度是比 Consumer 要快的，有 1MB/s 的这样的速度差，假定我们两端都有一个Buffer，Producer 端有一个发送用的 Send Buffer，Consumer 端有一个接收用的Receive Buffer，<strong>在网络端的吞吐率是 2MB/s，过了 5s 后我们的 Receive Buffer可能就撑不住了</strong>，这时候会面临两种情况：</p><ul><li>如果 Receive Buffer 是有界的，这时候新到达的数据就只能被丢弃掉了。</li><li>如果 Receive Buffer 是无界的，Receive Buffer 会持续的扩张，最终会导致 Consumer 的内存耗尽。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="网络流控的实现静态限速">网络流控的实现：静态限速<a href="#网络流控的实现静态限速" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="静态限速" src="/assets/images/87b91b28dfa1f7e421cc347332a104f-ba38c2b709530070b4e430f5453b7ef8.png" width="744" height="378" class="img_ev3q"></p><p>为了解决这个问题，我们就需要网络流控来解决上下游速度差的问题，传统的做法可以在<strong>Producer 端实现一个类似 Rate Limiter 这样的静态限流</strong>，Producer 的发送速率是 2MB/s，但是经过限流这一层后，<strong>往 Send Buffer 去传数据的时候就会降到 1MB/s 了</strong>，这样的话 Producer 端的发送速率跟 Consumer 端的处理速率就可以匹配起来了，就不会导致上述问题。但是这个解决方案有两点限制：</p><ul><li>事先无法预估 Consumer 到底能承受多大的速率。</li><li>Consumer 的承受能力通常会动态地波动。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="网络流控的实现动态反馈--自动反压">网络流控的实现：动态反馈 / 自动反压<a href="#网络流控的实现动态反馈--自动反压" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="自动反压" src="/assets/images/7b31485a910a4cca150d95666a401df-346481ec34a27ba4a420f78c972a84e7.png" width="680" height="285" class="img_ev3q"></p><p>针对静态限速的问题我们就演进到了动态反馈（自动反压）的机制，我<strong>们需要Consumer 能够及时的给 Producer 做一个 feedback</strong>，即告知 Producer 能够承的速率是多少。动态反馈分为两种：</p><ul><li>负反馈：接受速率小于发送速率时发生，告知 Producer 降低发送速率。</li><li>正反馈：发送速率小于接收速率时发生，告知 Producer 可以把发送速率提上来。</li></ul><p>让我们来看几个经典案例：</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="案例一storm-反压实现">案例一：Storm 反压实现<a href="#案例一storm-反压实现" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="自动反压" src="/assets/images/8174871d173e717bfdc0b3e5d65a8d2-8ec2d22e7ecc905d36f25fa08ad561bb.png" width="721" height="555" class="img_ev3q"></p><p>上图就是 Storm 里实现的反压机制，<strong>可以看到 Storm 在每一个 Bolt 都会有一个监测反压的线程（Backpressure Thread），这个线程一但检测到 Bolt 里的接收队列（recv queue）出现了严重阻塞就会把这个情况写到 ZooKeeper 里，ZooKeeper 会一直被 Spout 监听，监听到有反压的情况就会停止发送</strong>，通过这样的方式匹配上下游的发送接收速率。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="案例二spark-streaming-反压实现">案例二：Spark Streaming 反压实现<a href="#案例二spark-streaming-反压实现" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/09d86b57d9e6fa0f0e9e52d8448bae9-fb94252dc559d705bcd5ba8994c33512.png" width="582" height="317" class="img_ev3q"></p><p>Spark Streaming 里也有做类似这样的 feedback 机制，上图 Fecher 会实时的从 Buffer、Processing 这样的节点收集一些指标然后通过 Controller 把速度接收的情况再反馈到 Receiver，实现速率的匹配。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="疑问为什么-flinkbefore-v15里没有用类似的方式实现-feedback-机制">疑问：为什么 Flink（before V1.5）里没有用类似的方式实现 feedback 机制？<a href="#疑问为什么-flinkbefore-v15里没有用类似的方式实现-feedback-机制" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p>首先在解决这个疑问之前我们需要先了解一下 Flink 的网络传输是一个什么样的架构。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/c49f005a0a2cce35b26b376f601d8f8-a807d62e416b673fb25c452a72b10fe1.png" width="589" height="290" class="img_ev3q"></p><p>这张图就体现了 Flink 在做网络传输的时候基本的数据的流向，发送端在发送网络数据前要经历自己内部的一个流程，会有一个自己的 Network Buffer，在底层用 Netty 去做通信，Netty 这一层又有属于自己的 ChannelOutbound Buffer，因为最终是要通过 Socket 做网络请求的发送，所以在 Socket 也有自己的 Send Buffer，同样在接收端也有对应的三级 Buffer。学过计算机网络的时候我们应该了解到，<strong>TCP 是自带流量控制的。实际上 Flink （before V1.5）就是通过 TCP 的流控机制来实现 feedback 的</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-流控机制">TCP 流控机制<a href="#tcp-流控机制" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p>根据下图我们来简单的回顾一下 TCP 包的格式结构。首先，<strong>他有 Sequence number 这样一个机制给每个数据包做一个编号，还有 ACK number 这样一个机制来确保 TCP 的数据传输是可靠的，除此之外还有一个很重要的部分就是 Window Size，接收端在回复消息的时候会通过 Window Size 告诉发送端还可以发送多少数据</strong>。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/af1a3cd73cde2f4ba77ad9c6ee561f4-2346bb3d49828f1bbff5b866fd1da211.png" width="702" height="389" class="img_ev3q"></p><p>接下来我们来简单看一下这个过程。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/d1ba9d312809e00de8d84d170f8a60b-7de4836cbdec8fa4f9c9103a91dc03b1.png" width="804" height="438" class="img_ev3q"></p><p><strong>TCP 的流控就是基于滑动窗口的机制，现在我们有一个 Socket 的发送端和一个 Socket 的接收端</strong>，目前我们的<strong>发送端的速率是我们接收端的 3 倍</strong>，这样会发生什么样的一个情况呢？假定初始的时候我们发送的 window 大小是 3，然后我们接收端的 window 大小是固定的，就是接收端的 Buffer 大小为 5。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/a8ab541980b21a3742f4603a1d6b964-0f9628528c5c4674c07fe9503c01f55e.png" width="592" height="340" class="img_ev3q"></p><p>首先，发送端会一次性发 3 个 packets，将 1，2，3 发送给接收端，<strong>接收端接收到后会将这 3 个 packets 放到 Buffer 里去</strong>。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/8aa24a1d75141055ca0b4a99657d350-a551e546e6d01a1bc4072042550c98f1.png" width="584" height="320" class="img_ev3q"></p><p>接收端一次消费 1 个 packet，这时候 1 就已经被消费了，然后我们看到接收端的滑动窗口会往前滑动一格，<strong>这时候 2，3 还在 Buffer 当中 而 4，5，6 是空出来的</strong>，所以接收端会给发送端发送 ACK = 4 ，<strong>代表发送端可以从 4 开始发送，同时会将 window 设置为 3 （Buffer 的大小 5 减去已经存下的 2 和 3）</strong>，发送端接收到回应后也会将他的滑动窗口向前移动到 4，5，6。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/900fcfe5a4750d690ee0c361fe7ba25-cb2a9f11954a83d60bf28ea9e34351e2.png" width="604" height="353" class="img_ev3q"></p><p>这时候发送端将 4，5，6 发送，接收端也能成功的接收到 Buffer 中去。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/62fd0b4bf27ef2aae988426c9213d25-2c295a84d585859e5ecc526e11c58107.png" width="675" height="365" class="img_ev3q"></p><p>到这一阶段后，接收端就消费到 2 了，同样他的窗口也会向前滑动一个，<strong>这时候他的 Buffer 就只剩一个了，于是向发送端发送 ACK = 7、window = 1</strong>。发送端收到之后滑动窗口也向前移，但是这个时候就不能移动 3 格了，<strong>虽然发送端的速度允许发 3 个 packets 但是 window 传值已经告知只能接收一个，所以他的滑动窗口就只能往前移一格到 7</strong>，这样就<strong>达到了限流的效果</strong>，发送端的发送速度从 3 降到 1。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/d2673e48e261c36496c2858c4cc5aba-2f2116097c1d77926c1f0f2788d760de.png" width="698" height="379" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/af2a2e9082e04e53fdbdea4ee694f26-e3cbfafcc14bddcb277b0812c29e14fa.png" width="708" height="348" class="img_ev3q"></p><p>我们再看一下这种情况，<strong>这时候发送端将 7 发送后，接收端接收到，但是由于接收端的消费出现问题，一直没有从 Buffer 中去取，这时候接收端向发送端发送 ACK= 8、window =0 ，由于这个时候 window = 0，发送端是不能发送任何数据，也就会使发送端的发送速度降为 0</strong>。这个时候发送端不发送任何数据了，接收端也不进行任何的反馈了，那么如何知道消费端又开始消费了呢？</p><p><img loading="lazy" alt="反压实现" src="/assets/images/fc60a7e8c3fd871e46b7af0c3407dee-6b51a671549bea6304e5ea56f1e455d3.png" width="656" height="332" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/57519bddde5f4182750620cd2e13527-712444fabb4d015d5ae79f9c6f661c95.png" width="631" height="322" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/d335738258ea3f37aee0ee2ed872011-83788aefc468e4d188d48082914d2935.png" width="655" height="319" class="img_ev3q"></p><p>TCP 当中有一个 ZeroWindowProbe 的机制，<strong>发送端会定期的发送 1 个字节的探测消息，这时候接收端就会把 window 的大小进行反馈</strong>。当接收端的消费恢复了之后，接收到探测消息就可以将 window 反馈给发送端端了从而恢复整个流程。<strong>TCP 就是通过这样一个滑动窗口的机制实现 feedback</strong>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="flink-tcp-based-反压机制before-v15">Flink TCP-based 反压机制（before V1.5）<a href="#flink-tcp-based-反压机制before-v15" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="示例windowwordcount">示例：WindowWordCount<a href="#示例windowwordcount" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/1e99db234628407be700403a2446285-3b466c793e0d5f261d644ad80b121dca.png" width="762" height="307" class="img_ev3q"></p><p>大体的逻辑就是从 Socket 里去接收数据，每 5s 去进行一次 WordCount，将这个代码提交后就进入到了编译阶段。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="编译阶段生成-jobgraph">编译阶段：生成 JobGraph<a href="#编译阶段生成-jobgraph" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/c92f4827525e2b982a84a0da400d095-4c1260504c7f1c1a0958646c47115d4a.png" width="1009" height="394" class="img_ev3q"></p><p>这时候还没有向集群去提交任务，在 Client 端会将 StreamGraph 生成 JobGraph，<strong>JobGraph 就是做为向集群提交的最基本的单元</strong>。在生成 J<strong>obGrap 的时候会做一些优化，将一些没有 Shuffle 机制的节点进行合并</strong>。有了 JobGraph 后就会向集群进行提交，进入运行阶段。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="运行阶段调度-executiongraph">运行阶段：调度 ExecutionGraph<a href="#运行阶段调度-executiongraph" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/6d11b6fbceb0bb44a4440dfef19d469-9459af71b9e68cc22bea5c4bd63935df.png" width="1108" height="688" class="img_ev3q"></p><p>JobGraph 提交到集群后会生成 ExecutionGraph ，这时候就已经具备基本的执行任务的雏形了，<strong>把每个任务拆解成了不同的 SubTask</strong>，上图 ExecutionGraph 中的 <strong>Intermediate Result Partition 就是用于发送数据的模块</strong>，最终会将 ExecutionGraph 交给 JobManager 的调度器，将整个 ExecutionGraph 调度起来。</p><p>然后我们概念化这样一张物理执行图，<strong>可以看到每个 Task 在接收数据时都会通过这样一个 InputGate 可以认为是负责接收数据的</strong>，再往前有这样一个 ResultPartition 负责发送数据，<strong>在 ResultPartition 又会去做分区跟下游的 Task 保持一致，就形成了 ResultSubPartition 和 InputChannel 的对应关系</strong>。这就是从逻辑层上来看的网络传输的通道，基于这么一个概念我们可以将反压的问题进行拆解。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题拆解反压传播两个阶段">问题拆解：反压传播两个阶段<a href="#问题拆解反压传播两个阶段" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/781a920bc3c0dfe3694423566467760-3da078e98cf08abb392a87a37ccb3aa9.png" width="993" height="387" class="img_ev3q"></p><p>反压的传播实际上是分为两个阶段的，对应着上面的执行图，我们一共涉及 3 个 TaskManager，<strong>在每个 TaskManager 里面都有相应的 Task 在执行，还有负责接收数据InputGate，发送数据的 ResultPartition</strong>，这就是一个最基本的数据传输的通道。在这时候假设最下游的 Task （Sink）出现了问题，处理速度降了下来这时候是如何将这个压力反向传播回去呢？这时候就分为两种情况：</p><ul><li>跨 TaskManager ，反压如何从 InputGate 传播到 ResultPartition。</li><li>TaskManager 内，反压如何从 ResultPartition 传播到 InputGate。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="跨-taskmanager-数据传输">跨 TaskManager 数据传输<a href="#跨-taskmanager-数据传输" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/46ed54f1a2e2d5fbdc815c14ef57ff9-4a932f5671b1670fa41552567c8febff.png" width="982" height="447" class="img_ev3q"></p><p>前面提到，发送数据需要 ResultPartition，<strong>在每个 ResultPartition 里面会有分区 ResultSubPartition，中间还会有一些关于内存管理的 Buffer</strong>。对于一个 TaskManager <strong>来说会有一个统一的 Network BufferPool 被所有的 Task 共享</strong>，在初始化时会从 Off-heap Memory 中申请内存，申请到内存的后续内存管理就是同步 <strong>Network BufferPool 来进行的，不需要依赖 JVM GC 的机制去释放。有了 Network BufferPool 之后可以为每一个 ResultSubPartition 创建 Local BufferPool</strong>。</p><p>如上图左边的 TaskManager 的 Record Writer 写了 &lt;1，2&gt; 这个两个数据进来，因为 ResultSubPartition 初始化的时候为空，没有 Buffer 用来接收，就会向 Local BufferPool 申请内存，<strong>这时 Local BufferPool 也没有足够的内存于是将请求转到 Network BufferPool</strong>，<strong>最终将申请到的 Buffer 按原链路返还给 ResultSubPartition，&lt;1，2&gt; 这个两个数据就可以被写入了</strong>。</p><p><strong>之后会将 ResultSubPartition 的 Buffer 拷贝到 Netty 的 Buffer 当中最终拷贝到 Socket 的 Buffer 将消息发送出去</strong>。然后接收端按照类似的机制去处理将消息消费掉。接下来我们来模拟上下游处理速度不匹配的场景，发送端的速率为 2，接收端的速率为 1，看一下反压的过程是怎样的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="跨-taskmanager-反压过程">跨 TaskManager 反压过程<a href="#跨-taskmanager-反压过程" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/59613be253441a340f260eaa807e261-06240a5897a5900087563a3644078f35.png" width="982" height="457" class="img_ev3q"></p><p><strong>因为速度不匹配就会导致一段时间后 InputChannel 的 Buffer 被用尽</strong>，于是他会向 Local BufferPool 申请新的 Buffer ，这时候可以看到 Local BufferPool 中的一个 Buffer 就会被标记为 Used。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/7af6c4180431c969ee3367c9a9add75-8ef3ce837525db3e2b33213add843044.png" width="990" height="456" class="img_ev3q"></p><p>发送端还在持续以不匹配的速度发送数据，<strong>然后就会导致 InputChannel 向 Local BufferPool 申请 Buffer 的时候发现没有可用的 Buffer 了</strong>，这时候就只能向 Network BufferPool 去申请，<strong>当然每个 Local BufferPool 都有最大的可用的 Buffer</strong>，防止一个 Local BufferPool 把 Network BufferPool 耗尽。这时候看到Network BufferPool 还是有可用的 Buffer 可以向其申请。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/0129a70d4ca505ce98cf8c693d93dab-6a7928a289d2d7effe1d08c304827b78.png" width="872" height="408" class="img_ev3q"></p><p>一段时间后，<strong>发现 Network BufferPool 没有可用的 Buffer，或是 Local BufferPool 的最大可用 Buffer 到了上限无法向 Network BufferPool 申请</strong>，没有办法去读
取新的数据，<strong>这时 Netty AutoRead 就会被禁掉，Netty 就不会从 Socket 的 Buffer 中读取数据了</strong>。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/02331c2215957727ae933eead414804-b880ff87148f6d175dd1a118257dfed0.png" width="876" height="402" class="img_ev3q"></p><p>显然，再过不久 Socket 的 Buffer 也被用尽，<strong>这时就会将 Window = 0 发送给发送端（前文提到的 TCP 滑动窗口的机制）</strong>。这时发送端的 Socket 就会停止发送。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/3eb7225f72cb6c5780255e0767c7495-522a8e18e24ea75a5efe52c71e487666.png" width="995" height="458" class="img_ev3q"></p><p>很快发送端的 Socket 的 Buffer 也被用尽，<strong>Netty 检测到 Socket 无法写了之后就会停止向 Socket 写数据</strong>。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/6fdc054e640566f966a7055d6dc24f8-47c66790482c182948b13974f985f646.png" width="1144" height="512" class="img_ev3q"></p><p>Netty 停止写了之后，所有的数据就会阻塞在 Netty 的 Buffer 当中了，<strong>但是 Netty 的 Buffer 是无界的，可以通过 Netty 的水位机制中的 high watermark 控制他的上界。当超过了 high watermark，Netty 就会将其 channel 置为不可写，ResultSubPartition 在写之前都会检测 Netty 是否可写，发现不可写就会停止向 Netty 写数据</strong>。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/f819d7d9339518a526fb477e934dc2a-1c89119a2c78933df9d4a5820228b536.png" width="832" height="371" class="img_ev3q"></p><p>这时候所有的压力都来到了 ResultSubPartition，和接收端一样他会不断的向 Local BufferPool 和 Network BufferPool 申请内存。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/6ea5f87a1b0138fc8e4ec57fc3d5a1d-fca4c531992135c623094c4671c48346.png" width="746" height="341" class="img_ev3q"></p><p><strong>Local BufferPool 和 Network BufferPool 都用尽后整个 Operator 就会停止写数据，达到跨 TaskManager 的反压</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="taskmanager-内反压过程">TaskManager 内反压过程<a href="#taskmanager-内反压过程" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p>了解了跨 TaskManager 反压过程后再来看 TaskManager 内反压过程就更好理解了，<strong>下游的 TaskManager 反压导致本 TaskManager 的 ResultSubPartition 无法继续写入数据，于是 Record Writer 的写也被阻塞住了</strong>，因为 Operator 需要有输入才能有计算后的输出，输入跟输出都是在同一线程执行， <strong>Record Writer 阻塞了，Record Reader 也停止从 InputChannel 读数据，这时上游的 TaskManager 还在不断地发送数据，最终将这个 TaskManager 的 Buffer 耗尽</strong>。具体流程可以参考下图，这就是 TaskManager 内的反压过程。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/6af7eda70ab164f5d29eeb80af9bcd9-044043ba1e7ce3ab85247f59ed0f7daa.png" width="670" height="382" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/cc13df7bc6fb0868f025fc8340a9756-61b2bd62d12a8870af47f9eba0c690de.png" width="654" height="381" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/fe7d3cea0fcbf87768f8f5b1bf6c42c-3b036bd1c5057088ba908b4564ebca82.png" width="666" height="380" class="img_ev3q"></p><p><img loading="lazy" alt="反压实现" src="/assets/images/dc14ce9b84056625d29ae8af07e951d-3607a05009064a08b7cd4a68591f300e.png" width="608" height="320" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="flink-credit-based-反压机制since-v15">Flink Credit-based 反压机制（since V1.5）<a href="#flink-credit-based-反压机制since-v15" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-based-反压的弊端">TCP-based 反压的弊端<a href="#tcp-based-反压的弊端" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/f051736711146068df587dba564ef2a-17047459b6ae47383533a88d93e84a06.png" width="986" height="447" class="img_ev3q"></p><p>在介绍 Credit-based 反压机制之前，先分析下 TCP 反压有哪些弊端。</p><ul><li><p>在一个 TaskManager 中可能要执行多个 Task，<strong>如果多个 Task 的数据最终都要传输到下游的同一个 TaskManager 就会复用同一个 Socket 进行传输</strong>，这个时候如果单个 Task 产生反压，<strong>就会导致复用的 Socket 阻塞，其余的 Task 也无法使用传输</strong>，checkpoint barrier 也无法发出导致下游执行checkpoint 的延迟增大。</p></li><li><p>依赖最底层的 TCP 去做流控，会导致反压传播路径太长，导致生效的延迟比较大。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="引入-credit-based-反压">引入 Credit-based 反压<a href="#引入-credit-based-反压" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p>这个机制简单的理解起来就是在 Flink 层面实现类似 TCP 流控的反压机制来解决上述的弊端，<strong>Credit 可以类比为 TCP 的 Window 机制</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="credit-based-反压过程">Credit-based 反压过程<a href="#credit-based-反压过程" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="反压实现" src="/assets/images/5114e1cc6bb31feaa9b727a7d2181d4-ea7a37b4c4ce6d939b0559f18ca47571.png" width="994" height="469" class="img_ev3q"></p><p>如图所示在 Flink 层面实现反压机制，<strong>就是每一次 ResultSubPartition 向 InputChannel 发送消息的时候都会发送一个 backlog size 告诉下游准备发送多少消息，下游就会去计算有多少的 Buffer 去接收消息，算完之后如果有充足的 Buffer 就会返还给上游一个 Credit 告知他可以发送消息</strong>（图上两个 ResultSubPartition 和 InputChannel 之间是虚线是因为最终还是要通过 Netty 和 Socket 去通信），下面我们看一个具体示例。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/7f86ccd0f392eaf53c9324198a0fbad-0fc34301cdc11e6d15a495ec0e31d507.png" width="988" height="445" class="img_ev3q"></p><p><strong>假设我们上下游的速度不匹配，上游发送速率为 2，下游接收速率为 1</strong>，可以看到图上在 ResultSubPartition 中累积了两条消息，10 和 11， backlog 就为 2，这时就会将发送的数据 &lt;8,9&gt; 和 backlog = 2 一同发送给下游。下游收到了之后就会去计算是否有 2 个 Buffer 去接收，可以看到 InputChannel 中已经不足了这时就会从 Local BufferPool 和 Network BufferPool 申请，好在这个时候 Buffer 还是可以申请到的。</p><p><img loading="lazy" alt="反压实现" src="/assets/images/31041594fb4fdc9a2c7f15f25ba3889-a7634cc0d2bd9e81480b29e6e59be579.png" width="863" height="389" class="img_ev3q"></p><p>过了一段时间后由于上游的发送速率要大于下游的接受速率，<strong>下游的 TaskManager 的 Buffer 已经到达了申请上限，这时候下游就会向上游返回 Credit = 0</strong>，ResultSubPartition 接收到之后就不会向 Netty 去传输数据，上游 TaskManager 的 Buffer 也很快耗尽，达到反压的效果，<strong>这样在 ResultSubPartition 层就能感知到反压，不用通过 Socket 和 Netty 一层层地向上反馈，降低了反压生效的延迟</strong>。同时也不会将 Socket 去阻塞，<strong>解决了由于一个 Task 反压导致 TaskManager 和 TaskManager 之间的 Socket 阻塞的问题。</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结与思考">总结与思考<a href="#总结与思考" class="hash-link" aria-label="标题的直接链接" title="标题的直接链接">​</a></h2><ol><li>Credit-based 反压是 TCP-based 反压的抽象实现，达到了更加细粒度的反压控制。</li><li>网络流控是为了在上下游速度不匹配的情况下，防止下游出现过载。</li><li><strong>网络流控有静态限速和动态反压两种手段</strong>。</li><li>Flink 1.5 之前是基于 TCP 流控 + bounded buffer 实现反压。</li><li><strong>Flink 1.5 之后实现了自己托管的 credit - based 流控机制，在应用层模拟 TCP 的流控机制</strong>。</li></ol><p>思考：有了动态反压，静态限速是不是完全没有作用了？</p><p><img loading="lazy" alt="反压实现" src="/assets/images/36641b4c17eec95fae8c484e25e584b-4616aae9afaf7ae6edf4cf7488e7c591.png" width="1015" height="365" class="img_ev3q"></p><p><strong>实际上动态反压不是万能的</strong>，我们流计算的结果最终是要输出到一个外部的存储（Storage），<strong>外部数据存储到 Sink 端的反压是不一定会触发的</strong>，这要取决于外部存储的实现，<strong>像 Kafka 这样是实现了限流限速的消息中间件可以通过协议将反压反馈给 Sink 端</strong>，但是像 ES 无法将反压进行传播反馈给 Sink 端，这种情况下为了防止外部存储在大的数据量下被打爆，<strong>我们就可以通过静态限速的方式在 Source 端去做限流</strong>。</p><p><strong>所以说动态反压并不能完全替代静态限速的，需要根据合适的场景去选择处理方案。</strong></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/zhangyongtian/bigdataknowledge/tree/dev/docs/数据开发/Apache Flink/理论/网络流控及反压剖析.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/数据开发/Apache Flink/理论/Flink 作业执行深度解析"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Flink 作业执行深度解析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/数据开发/Apache Flink/理论/End-to-End-Exactly-Once"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">End-to-End-Exactly-Once</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#网络流控的概念与背景" class="table-of-contents__link toc-highlight">网络流控的概念与背景</a><ul><li><a href="#为什么需要网络流控" class="table-of-contents__link toc-highlight">为什么需要网络流控</a></li><li><a href="#网络流控的实现静态限速" class="table-of-contents__link toc-highlight">网络流控的实现：静态限速</a></li><li><a href="#网络流控的实现动态反馈--自动反压" class="table-of-contents__link toc-highlight">网络流控的实现：动态反馈 / 自动反压</a></li><li><a href="#案例一storm-反压实现" class="table-of-contents__link toc-highlight">案例一：Storm 反压实现</a></li><li><a href="#案例二spark-streaming-反压实现" class="table-of-contents__link toc-highlight">案例二：Spark Streaming 反压实现</a></li><li><a href="#疑问为什么-flinkbefore-v15里没有用类似的方式实现-feedback-机制" class="table-of-contents__link toc-highlight">疑问：为什么 Flink（before V1.5）里没有用类似的方式实现 feedback 机制？</a></li><li><a href="#tcp-流控机制" class="table-of-contents__link toc-highlight">TCP 流控机制</a></li></ul></li><li><a href="#flink-tcp-based-反压机制before-v15" class="table-of-contents__link toc-highlight">Flink TCP-based 反压机制（before V1.5）</a><ul><li><a href="#示例windowwordcount" class="table-of-contents__link toc-highlight">示例：WindowWordCount</a></li><li><a href="#编译阶段生成-jobgraph" class="table-of-contents__link toc-highlight">编译阶段：生成 JobGraph</a></li><li><a href="#运行阶段调度-executiongraph" class="table-of-contents__link toc-highlight">运行阶段：调度 ExecutionGraph</a></li><li><a href="#问题拆解反压传播两个阶段" class="table-of-contents__link toc-highlight">问题拆解：反压传播两个阶段</a></li><li><a href="#跨-taskmanager-数据传输" class="table-of-contents__link toc-highlight">跨 TaskManager 数据传输</a></li><li><a href="#跨-taskmanager-反压过程" class="table-of-contents__link toc-highlight">跨 TaskManager 反压过程</a></li><li><a href="#taskmanager-内反压过程" class="table-of-contents__link toc-highlight">TaskManager 内反压过程</a></li></ul></li><li><a href="#flink-credit-based-反压机制since-v15" class="table-of-contents__link toc-highlight">Flink Credit-based 反压机制（since V1.5）</a><ul><li><a href="#tcp-based-反压的弊端" class="table-of-contents__link toc-highlight">TCP-based 反压的弊端</a></li><li><a href="#引入-credit-based-反压" class="table-of-contents__link toc-highlight">引入 Credit-based 反压</a></li><li><a href="#credit-based-反压过程" class="table-of-contents__link toc-highlight">Credit-based 反压过程</a></li></ul></li><li><a href="#总结与思考" class="table-of-contents__link toc-highlight">总结与思考</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/概览">文档</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/zhangyongtian/bigdataknowledge" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github Discussion<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">博客</a></li><li class="footer__item"><a href="https://github.com/zhangyongtian/bigdataknowledge" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub Issues<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4dcd1c4b.js"></script>
<script src="/assets/js/main.d89d1304.js"></script>
</body>
</html>